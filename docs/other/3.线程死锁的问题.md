---
title: 线程死锁的问题
---
# 线程死锁的问题

死锁是多个线程在运行过程中因争夺资源而相互等待，导致“永久”阻塞的一种情况。

预防和解决死锁的方法包括：

1. 资源排序: 保证所有线程按照相同的顺序请求资源，这样可以避免循环等待的条件，从而预防死锁。列如A、B两个资源，为每个资源分配一个唯一的序号，线程必须按照序号的升序请求资源，并按照序号的降序释放资源。通过这样的方式可以保证线程不会行程循环，从而避免了死锁。

2. 超时机制:为线程获取资源的操作设置超时时间，超时后线程可以放弃等待，回退并重新尝试，这样可以避免线程永久阻塞。

3. 死锁检测与恢复: 使用算法定期检测系统是否进入死锁状态，一旦检测到死锁，通过强制释放某些资源或终止某些线程来恢复系统正常运行。
   
预防死锁的关键是合理的设计资源分配策略和线程调度机制，确保系统在运行过程中不会出现不可解的资源竞争。

## 面试题：如何避免死锁
1. 可以设置超时机制，避免死锁
2. 通过对资源排序避免死锁
3. 还有一种死锁，是同一线程重复获取同一资源的死锁，可以使用可`重入锁`来避免这种情况。

## 资源排序的实现案例
```java
public class Resource {
    private final String name;

    public Resource(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

public class ResourceOrderingExample {
    private final Resource resource1 = new Resource("Resource1");
    private final Resource resource2 = new Resource("Resource2");

    public void acquireResourcesInOrder() {
        synchronized (resource1) {
            System.out.println(Thread.currentThread().getName() + " acquired " + resource1.getName());
            synchronized (resource2) {
                System.out.println(Thread.currentThread().getName() + " acquired " + resource2.getName());
                // Perform operations with both resources
            }
        }
    }

    public void acquireResourcesInReverseOrder() {
        synchronized (resource2) {
            System.out.println(Thread.currentThread().getName() + " acquired " + resource2.getName());
            synchronized (resource1) {
                System.out.println(Thread.currentThread().getName() + " acquired " + resource1.getName());
                // Perform operations with both resources
            }
        }
    }

    public static void main(String[] args) {
        ResourceOrderingExample example = new ResourceOrderingExample();

        Runnable task1 = () -> {
            example.acquireResourcesInOrder();
        };

        Runnable task2 = () -> {
            example.acquireResourcesInOrder();
        };

        Thread thread1 = new Thread(task1, "Thread-1");
        Thread thread2 = new Thread(task2, "Thread-2");

        thread1.start();
        thread2.start();
    }
}


```