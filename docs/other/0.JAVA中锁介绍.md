---
title: JAVA中锁介绍
---
# JAVA中锁介绍

## 乐观锁与悲观锁
1. 乐观锁

乐观锁通过假设并发冲突发生概率较低来解决并发问题，主要通过数据版本控制实现。在更新数据前，会检查数据版本是否发生变化，只有在数据版本未变时才允许更新，这样可以避免覆盖其他线程所做的更改。


2. 悲观锁

悲观锁通常用于解决高并发下的数据安全问题，尤其是在写操作频繁的场景中。它通过锁定数据来防止其他线程并发修改，确保数据操作的原子性、一致性和隔离性。

## 自旋锁和CAS失败自旋

这里我把两个来比较是为了区别，其中`CAS失败自旋`不等于自旋锁，这是两种不同概念的。自旋锁是用于互斥锁定，而CAS是用于无锁并发操作。

1. 自旋锁
   
自旋锁是一种不使用操作系统级别的阻塞机制，而是通过让线程不断尝试获取锁的方式实现的锁机制。自旋锁在高并发环境下可以减少线程上下文切换的开销，但如果自旋时间过长，可能会导致CPU资源浪费。

2. CAS （一种无锁并发交换）
   
CAS（Compare-And-Swap）是一种用于实现无锁并发的原子操作，广泛应用于多线程编程中。CAS操作包含三个操作数：内存位置（V）、预期原值（A）和新值（B）。在交换失败时线程可以选择继续尝试`（自旋重试）或放弃操作`。

缺点：

* ABA问题：如果一个变量从A变为B然后又变回A，CAS操作无法检测到这种变化。解决方法之一是使用版本号。
* 自旋等待：CAS在失败时会自旋重试，可能会导致CPU资源浪费，尤其是在高并发情况下。
* 只能操作一个变量：CAS只能操作一个共享变量，无法直接处理多个变量的原子操作。

## 重入锁

可重入锁的主要特点是同一线程可以多次获得同一把锁，这对于避免死锁和提高编程灵活性具有重要意义。其内部维护了一个计数器，当前线程多次获取持有的锁时计数器自动+1，释放锁时-1，当计数器为0时则正在的释放锁。

可重入锁支持在一个已加锁的方法中调用另一个需要相同锁的方法。

JAVA中提供的一些可重入锁有：`ReentrantLock` 、`synchronized关键字`

优点：`避免死锁`（因线程等待自己持有的锁导致的死锁）,`编程灵活性`(支持在一个已加锁的方法中调用另一个需要相同锁的方法,提高代码的复用性和模块化)。

## 读写锁、共享锁、排它锁

1. 读写锁
   
读写锁是一种允许多个线程同时读取但只允许一个线程写入的锁。JAVA中`ReentrantReadWriteLock` 则是读写锁的一种，它分为两种锁类型：

* 读锁（共享锁）：允许多个读者同时访问资源，但当有写者请求写锁时，读者需要等待写者释放写锁。
* 写锁（排它锁）：只允许一个写者访问资源，写者在持有写锁时，其他读者和写者都必须等待。

2. 共享锁（适用于读多写少）
   
共享锁允许多个线程同事访问资源，但是不能去修改资源。通常用于读操作，如果资源被添加了排它锁（写锁）时，那么获取到共享锁的线程必须等待`写锁`释放完毕。

3. 排它锁

排它锁保正同一时间只有一个线程可以访问资源。当一个线程持有排它锁时，其它线程不能访问改资源包括读操作。

## 公平锁、非公平锁

公平锁在Java中是指多个线程按照请求锁的顺序来获取锁的机制。这种锁会维护一个有序队列，确保按照线程请求的顺序来分配锁，避免线程饥饿问题，根据是否按照`请求锁`的顺序`获取锁`来判断是否为公平锁。

ReentrantLock 可以通过构造函数来实现公平锁和非公平锁，默认是非公平锁。


* 请求顺序：公平锁通过维护一个等待队列来保证锁分配的顺序性
* 避免饥饿线程的问题，但是现对于的没有非公平锁效率高。

